\section{Modellprädiktive Regelung}
Modellprädiktive Regelung ist quasi eine iterative Berechnung einer optimalen Steuerung mit der Rückführung der Zustände zum jeweiligen Zeitpunkt. Sie findet in vielen Bereichen immer häufiger Anwendung, da sie eine direkte Berücksichtigung von Beschränkungen ermöglicht und einen strukturierten Reglerentwurf darstellt (Modellierung -> Optimierung, Angabe einer geeigneten Kostenfunktion) Allerdings ergeben sich auch Schwierigkeiten bei der Verwendung von modellprädiktiven Regelungen. Zum einen ist die Konvergenz der Optimierung gegen einen optimalen Wert für die Eingangsgröße und die Stabiltät des geschlossenen Kreises oft nur schwierig nachweisbar und zum anderen stellt das schnelle Online-Lösen des oft hochdimensionalen Optimierungsproblems eine Herausforderung dar.
\\
\subsection{Grundlagen der modellprädiktiven Regelung}
Im realen Anwenungsfall des oTToCAR-Projekts eignet sich eine Systemdarstellung in zeitdiskreter Form mehr als in kontinuierlicher Form, bei der die Optimierung außerdem meist komplexer ist. Demnach liegen die Systemgleichung in folgender Form vor:
\begin{align}
  \boldsymbol{x}(k+1)&=\boldsymbol{f}\left ( \boldsymbol{x}(k), \boldsymbol{u}(k) \right )\\
	\boldsymbol{y}(k)&=\boldsymbol{g}\left ( \boldsymbol{x}(k) \right )\\
	mit\\
	&\boldsymbol{x}(k) \in \mathcal{X}\subset\mathbb{R}^n\\
	&\boldsymbol{u}(k) \in \mathcal{U}\subset\mathbb{R}^m\\
	&\boldsymbol{y}(k) \in \mathcal{Y}\subset\mathbb{R}^r
\end{align}
Ausgehend vom aktuellen Zustand $x(k)$ des zu regelnden Systems, der wenn nicht messbar geschätzt werden muss, wird anhand des Systemmodells das zukünftige Systemverhalten
\begin{align}
  \left\{ \boldsymbol{x}(k+1),\dots,\boldsymbol{x}(k+n_p)\right\}
\end{align}
bis zum Prädiktionshorizont $n_p$ unter der Optimierung einer Sequenz von Eingängen
\begin{align}
  \boldsymbol{u}=\left\{ \boldsymbol{u}(k),\dots,\boldsymbol{u}(k+n_c-1)\right\}
\end{align}
bis zum Stellhorizont $n_c$ vorhergesagt. Aus der gefundenen optimalen Eingangssequenz $u^*$ wird der erste Eintrag $u^*(k)$ auf das zu regelnde System angewandt. Nach der Zeit $\delta t$ kann der neue Zustand gemessen werden und die Optimierung beginnt von neuem.\\ \\
Bei der Optimierung wird meist eine quadratische Kostenfunktion mit $x(k)$ und $u(k)$ als Optimierungsvariablen aufgestellt:
\begin{align}
	\underset{\boldsymbol{u}}{\text{min}}\;J:=\sum_{i=k}^{k+n_p-1}l(\boldsymbol{x}(i),\boldsymbol{u}(i)))+F(\boldsymbol{x}(k+n_p))\\
	\underset{\boldsymbol{u}}{\text{min}}\;J:=\sum_{i=k}^{k+n_p-1}l(\boldsymbol{x}(i),\boldsymbol{u}(i)))+F(\boldsymbol{x}(k+n_p))\\
	\underset{\boldsymbol{u}}{\text{min}}\;J:=\sum_{i=k+1}^{k+n_p}\left \| \boldsymbol{x}(i)-\boldsymbol{x}_r(i)  \right \|_{Q}^{2} +\sum_{i=k}^{k+n_c-1}\left \| \boldsymbol{u}(i) \right \|_{R}^{2}\\
	\underset{\boldsymbol{u}}{\text{min}}\;J:=\left \| \boldsymbol{x}_p(k)-\boldsymbol{x}_r(k)  \right \|_{Q}^{2} +\left \| \Delta\boldsymbol{u}(k) \right \|_{R}^{2}\\
	\boldsymbol{x}_p(k)&=\left [ \boldsymbol{x}_p(k+1\mid k),\dots,\boldsymbol{x}_p(k+n_p\mid k) \right ]^T\\
	\boldsymbol{x}_r(k)&=\left [ \boldsymbol{x}_r(k+1),\dots,\boldsymbol{x}_r(k+n_p) \right ]^T\\
	\Delta\boldsymbol{u}(k)&=\left [ \Delta\boldsymbol{u}(k),\dots,\Delta\boldsymbol{u}(k+n_u-1) \right ]^T
\end{align}
Wobei die Wichtungtungen Vorausetzungen erfüllen müssen.\\
Linear MPC/Nonlinear MPC\\
Beschränkungen
\subsection{Konkrete Umsetzung der modellprädiktiven Regelung am oTToCAR}
u setzt sich zusammen aus Stellgröße Servo für den Lenkeinschlag und Stellgröße für den Motor für die Beschleunigung. Dabei wird n Schritte in die Zukunft geschaut, woraus ein Optimierungsvektor der Dimension R=irgendwas resultiert. Je größer man n wählt, desto besser lässt sich z.B. die Geschwindigkeit in Abhängigkeit zur Entfernung und Krümmung einer bevorstehenden Kurve ">anpassen"< oder Schwierigkeiten beim Durchfahren einer S-Kurve überwinden. Allerdings nimmt dadurch auch die Komplexität der Optimierung zu und man stößt schnell an die Grenzen der verfügbaren Rechenzeit/Recourcen.\\ \\
Verarbeitung der Polylinien\\
Interpolation\\
Parameter s aus der Geschwindigkeit bestimmen\\
An Polylinien entlang fahren\\ \\
Vereinfachungen\\
Aktuell wird die Motorsteuergröße nicht mitoptimiert und der Prädiktionshorizont beträgt 1. In dieser Konfiguration gibt es sicher Algorithmen wie LQR die Äquivalente Lösungen liefern und dabei besser nachweisbare Stabilität aufweisen. Es wurde sich trotzdem für die vereinfachte Variante entschieden, um diese in Zukunft so wie geplant zu erweitern.
Stabilität\\
Um Sicher zu gehen, dass der Algorithmus immer gegen ein Optimum konvergiert wurde die in implementierten Fall skalare Kostenfunktionen in der Parcour fahrt in möglichst vielen denkbaren Positionen aufgenommen und überprüft, dass sich kein Fall ergibt, in dem das Optimierungsproblem in relevanten Bereich nicht convex ist.
\\
Parabeln
\\
Es genügt den Scheitelpunkt der approximierten Variablen zu berechnen. genau genug.
Skalierbarkeit\\
Hinzufügen von Beschränkungen
Scheitelpunkt -> Newtonschritt der quadratischen Kostenfunktion
Aufwand\\
Nochmal überlegen\\
In der Vorbereitung auf den Wettkampf hat sich herausgestellt, dass die kurzen Testzeiten auf der Originalstrecke gut ausgenutzt werden muss. Dazu musste vorher extrahiert werden, welche Parameter entscheidenen Einfluss auf die Güte haben. Diese konnten dann online während der Fahrt mit dem dynamic reconfigure Paket getuned werden. (welche Parameter)\\
keine neue Polylinie\\
\subsection{Zukünftige Schritte}
Geschwindigkeit, mehrere Schritte in die Zukunft, Erstellung einer Karte mit Gewichtung der Confidence der Polylinien